# 2026-02-09: Post-#26 follow-up (issues #19, #6, #5)

## Environment check

- Confirmed ADB endpoint is reachable: `192.168.1.160:38087`
- `adb connect` succeeds and `adb shell wm size` responds
- `vmictl.py battery` works (55%)

## #19 humidity validation attempt

Tried running a fresh checkpoint capture session after merge #26.

Observed blocker:
- UI dumps show `com.android.systemui` keyguard/lockscreen as top window
- `vmictl` navigation commands that require app selectors can stall while waiting for elements when device is locked

Action taken:
- Added `scripts/capture/preflight_capture.py` to check connectivity + keyguard state before running long capture flows
- Added issue #19 runbook in `docs/reverse-engineering/playbook.md` with explicit per-step checkpoints and extraction commands

## #6 night ventilation decoding

Action taken:
- Added concrete runbook (3-run method, delayed checkpoint at +15s, extraction commands) in playbook
- Includes `analyze_settings_packets.py` post-processing step for candidate packet path detection

## #5 bypass state (weather-dependent)

Action taken:
- Added practical capture plan/checklist in playbook focused on observational checkpoints only (no risky writes)
- Added structured worksheet guidance to correlate icon state, weather, and candidate status bytes

## Follow-up capture attempt (ADB 192.168.1.160:38087)

### #19 humidity validation

- Re-ran preflight with explicit target: device reachable + keyguard unlocked.
- `vmictl connect` now works reliably and reaches VMI+ foreground.
- Completed a partial checkpoint session and successfully pulled snoop log:
  - `data/captures/issue19_humidity_validation_run_20260209_150708/btsnoop.log`
  - 1278 VMI packets extracted (639 writes / 639 notifies)
  - Confirmed again: `DEVICE_STATE` byte 4 stayed fixed at **55** across the run while probe humidity byte 8 moved (64→65 in sampled packets), so no new evidence yet that byte 4 tracks live humidity.
- Limitation: only one timestamped checkpoint was captured before UI selector flow stalled on deeper sensor-navigation commands, so app-value correlation is still incomplete.

### #6 night ventilation decoding

- Reached `special-modes-full` and captured a baseline screenshot checkpoint.
- Session-end bugreport pull intermittently failed with ADB-over-WiFi protocol faults, limiting controlled multi-run execution.
- From the successful #19 snoop, extracted non-polling request candidates worth targeting in dedicated #6 runs:
  - `REQUEST param 0x1c` with values `{0x0e, 0x10, 0x12}` (6 packets total)
  - `REQUEST param 0x17` with values `{0x19, 0x1a}` (2 packets total)
- These are now concrete candidate opcodes for Special Modes-related toggles, but still unproven without clean ON/OFF checkpoint correlation.

### #5 bypass state

- Bypass remained observational-only; no bypass-icon transition capture achieved in this window.
- Existing runbook remains the ready-to-run path pending natural weather-driven icon transitions.

### Tooling improvement

- Hardened `vmictl session-end` bugreport collection with one retry + ADB reconnect on failure.
- Change is in `scripts/capture/vmictl_lib/controller.py` and directly targets intermittent `adb bugreport` protocol faults seen today.

## #21 SETTINGS airflow bytes investigation

### Question

What do SETTINGS bytes 9-10 ("airflow bytes") and byte 7 actually encode?
The library has `AIRFLOW_BYTES` with three byte pairs extracted from early
captures: LOW=(0x19, 0x0A), MEDIUM=(0x28, 0x15), HIGH=(0x07, 0x30).

### Method

Analyzed all SETTINGS packets from two independent controlled captures:
- `fan_speed_capture_20260207_171617`: 5 SETTINGS packets
- `issue19_humidity_validation_run_20260209_150708`: 13 SETTINGS packets

Decoded bytes 7-10 under both the old config interpretation (summer limit,
preheat temp, airflow bytes) and the clock sync interpretation (day, hour,
minute, second).

### Findings

**Bytes 9-10 are minute:second (clock sync).** All 18 SETTINGS packets across
both captures decode as valid timestamps with monotonically increasing hours
and sensible minute/second values. The day values (byte 7) match the capture
dates: 0x07 = Feb 7, 0x08 = Feb 8, 0x09 = Feb 9.

**Byte 7 is day-of-month, not a mode selector.** Values 0x06-0x09 observed.

**Byte 8 is the hour, not preheat temperature.** Several captured packets have
byte 8 = 0x09 (hour 9) which is outside the valid preheat range (12-18°C),
disproving the preheat temperature interpretation.

**The "airflow bytes" were clock sync artifacts.** The pairs from early
captures (0x19/0x0A = min 25/sec 10, etc.) are plausible minute:second values.
No controlled capture contains SETTINGS packets with these specific byte pairs.

**No SETTINGS packet with byte 7 = 0x00 or 0x02 has been observed in any
controlled capture.** The early-capture values that motivated `SettingsMode.NORMAL`
and `SettingsMode.SUMMER_LIMIT` may have been low day-of-month values.

### Impact on codebase

- `AIRFLOW_BYTES` constant: contains clock sync artifacts, not airflow config
- `SettingsMode.NORMAL` / `SUMMER_LIMIT`: unverified mode codes
- `build_settings_packet()`: sends bytes the phone never sends
- `set_summer_limit()`: uses build_settings_packet() and reportedly works,
  but exact mechanism is unclear

### Changes made

- Added investigation comments to `AIRFLOW_BYTES`, `SettingsMode`, and
  `build_settings_packet()` in protocol.py
- Updated protocol.md §7.1 with full evidence tables from both captures
- Updated protocol.md open questions (marked SETTINGS bytes as resolved)
- Updated implementation-status.md
- Added `TestSettingsClockSync` test class with 12 captured packet vectors
- No behavioral changes — symbols and function signatures unchanged

### Open

- Whether the device firmware supports config-mode SETTINGS (byte 7 <= 0x05)
  alongside clock sync (byte 7 >= 0x06) is unverified
- A capture of the phone's summer limit toggle would clarify how the phone
  actually changes summer limit settings (SETTINGS vs some other mechanism)

## Notes

No risky device writes were performed intentionally in this session; all observed writes were from normal app polling/background behavior during capture.
