# 2026-02-06: Packet type audit across all captures

## Goal

Scan all btsnoop captures for previously undocumented packet types, prompted
by a firmware update done on Feb 5.

## Method

1. Ran `extract_packets.py` on all 43 btsnoop logs and 10 structured capture sessions
2. Identified all packet types reported as `UNKNOWN_xx`
3. Validated each by checking ATT framing (real VMI packets are preceded by
   `1b 0e 00` for notifications or `12 13 00` for commands)

## Findings

### New packet: 0x40 (Schedule Config Write)

A **command** (written to handle 0x0013) that writes schedule configuration
to the device. Identical structure to 0x46 (Schedule Config response) but
sent as a 55-byte command instead of a 182-byte padded notification.

**Structure:**
```
a5b6 40 06 31 00 [24 x 2-byte slots] [checksum]
```

- Bytes 0-1: Magic `a5b6`
- Byte 2: Type `0x40`
- Bytes 3-5: Header `06 31 00` (same as 0x46)
- Bytes 6-53: 24 time slots (2 bytes each: preheat temp, mode byte)
- Byte 54: XOR checksum

**Mode byte values** (same encoding as 0x46):

| Mode | Byte |
|------|------|
| LOW  | 0x28 (40) |
| MEDIUM | 0x32 (50) |
| HIGH | ? (not captured) |

**Observed examples (from btsnoop_20260205_100208):**
- 4 instances at 10:05-10:09 on Feb 5
- User changed hour 1 from LOW to MEDIUM, then back
- XOR checksum verified correct

**Comparison with 0x46:**
- 0x40 = app writes schedule TO device (55 bytes, command)
- 0x46 = device reports schedule TO app (182 bytes, notification, zero-padded)
- Same slot encoding, same header after magic+type

### False positives identified

The `extract_packets.py` tool finds `a5b6` patterns by scanning concatenated
HCI record data. This produces false matches when `a5b6` appears coincidentally
in non-VMI BLE data.

**Confirmed false positives** (no ATT framing):

| Type | Capture | Notes |
|------|---------|-------|
| 0x08, 0x94, 0x5e, 0x44, 0xa3, 0x80, 0xd2 | btsnoop_20260203_200749 | Burst at 15:18-15:19, random-looking data |
| 0x3c, 0xd0 | btsnoop_20260203_200749 | At 15:32, random data |
| 0x0d | btsnoop_20260205_100208 | Preceded by `01819f`, not ATT |
| 0x41 | btsnoop_20260204_183225+ | Preceded by `d56d8c`, not ATT |
| 1x 0x46 | btsnoop_20260203_200749 | One of two 0x46 matches was false |

### Already-documented packets confirmed

| Type | Role | First seen | Count across captures |
|------|------|------------|----------------------|
| 0x46 (Schedule Config) | Notification | Feb 3 | Occasional |
| 0x47 (Schedule Query) | Notification | Feb 3 | Occasional |
| 0x50 (Holiday Status) | Notification | Feb 2 (earliest capture) | Every capture |

0x50 has been present since our earliest captures, so it's not new to the
firmware update.

## Extractor improvement needed

The `extract_packets.py` name map is missing 0x40, 0x46, 0x47, and 0x50.
It also has no false-positive filtering (ATT framing check). These could be
improved to reduce noise in future analysis.

## Open questions

- Is 0x40 the only way to write schedule config, or does 0x1a (SETTINGS) with
  mode byte 0x05 also play a role?
- What triggers the device to send 0x47 (Schedule Query)?
- Is there a HIGH mode byte for schedule slots (only LOW=0x28 and MEDIUM=0x32
  captured so far)?
- Did the firmware update change any packet behavior, or are the "new" 0x40
  packets just the first time we captured a schedule write?

---

# 2026-02-06: Holiday mode fully decoded and implemented (Issue #3)

## Verification capture

Ran a controlled capture session (`holiday_verify_byte43_20260206_100345`) with
four checkpoints: OFF → 3 days → 7 days → OFF.

**Byte 43 transitions observed in DEVICE_STATE packets:**
- `0 → 3` (holiday set to 3 days)
- `3 → 7` (changed to 7 days)
- `7 → 0` (holiday cleared)

All transitions match the values sent via REQUEST param 0x1a. Confirmed across
both Feb 5 and Feb 6 captures (values 0, 3, 5, 7 all observed).

## Key discovery: Device responds with DEVICE_STATE, not SETTINGS_ACK

When the device receives a holiday command (REQUEST param 0x1a), it responds
with a **DEVICE_STATE** packet (~130ms later), NOT a SETTINGS_ACK. This is
different from SETTINGS commands which do get SETTINGS_ACK.

The initial `set_holiday()` implementation waited for SETTINGS_ACK (following
the `set_boost()` pattern) and timed out in e2e tests. Fixed to wait for
DEVICE_STATE instead.

Note: `set_boost()` also gets DEVICE_STATE responses, not SETTINGS_ACK. It
works in the VMI app workflow because the app sends a full data request
afterward which triggers ACK. Standalone usage might also have this issue.

## Implementation

- `build_holiday_command(days)` — sends REQUEST 0x1a with days in byte 9
- `DeviceStatus.holiday_days` — parsed from DEVICE_STATE byte 43
- `VisionAirClient.set_holiday(days)` / `clear_holiday()` — client methods
- Removed `build_request_1a()` and `build_holiday_activate()` (dead code)
- E2e test passes: set 3 days → verify holiday_days=3 → clear → verify 0

## Open questions resolved

- Holiday mode: fully decoded, no separate activation packet needed
- 0x50 response: constant, not useful for state monitoring
- Byte 43: reliable source for holiday days remaining
