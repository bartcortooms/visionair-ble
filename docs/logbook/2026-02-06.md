# 2026-02-06: Packet type audit across all captures

## Goal

Scan all btsnoop captures for previously undocumented packet types, prompted
by a firmware update done on Feb 5.

## Method

1. Ran `extract_packets.py` on all 43 btsnoop logs and 10 structured capture sessions
2. Identified all packet types reported as `UNKNOWN_xx`
3. Validated each by checking ATT framing (real VMI packets are preceded by
   `1b 0e 00` for notifications or `12 13 00` for commands)

## Findings

### New packet: 0x40 (Schedule Config Write)

A **command** (written to handle 0x0013) that writes schedule configuration
to the device. Identical structure to 0x46 (Schedule Config response) but
sent as a 55-byte command instead of a 182-byte padded notification.

**Structure:**
```
a5b6 40 06 31 00 [24 x 2-byte slots] [checksum]
```

- Bytes 0-1: Magic `a5b6`
- Byte 2: Type `0x40`
- Bytes 3-5: Header `06 31 00` (same as 0x46)
- Bytes 6-53: 24 time slots (2 bytes each: preheat temp, mode byte)
- Byte 54: XOR checksum

**Mode byte values** (same encoding as 0x46):

| Mode | Byte |
|------|------|
| LOW  | 0x28 (40) |
| MEDIUM | 0x32 (50) |
| HIGH | ? (not captured) |

**Observed examples (from btsnoop_20260205_100208):**
- 4 instances at 10:05-10:09 on Feb 5
- User changed hour 1 from LOW to MEDIUM, then back
- XOR checksum verified correct

**Comparison with 0x46:**
- 0x40 = app writes schedule TO device (55 bytes, command)
- 0x46 = device reports schedule TO app (182 bytes, notification, zero-padded)
- Same slot encoding, same header after magic+type

### False positives identified

The `extract_packets.py` tool finds `a5b6` patterns by scanning concatenated
HCI record data. This produces false matches when `a5b6` appears coincidentally
in non-VMI BLE data.

**Confirmed false positives** (no ATT framing):

| Type | Capture | Notes |
|------|---------|-------|
| 0x08, 0x94, 0x5e, 0x44, 0xa3, 0x80, 0xd2 | btsnoop_20260203_200749 | Burst at 15:18-15:19, random-looking data |
| 0x3c, 0xd0 | btsnoop_20260203_200749 | At 15:32, random data |
| 0x0d | btsnoop_20260205_100208 | Preceded by `01819f`, not ATT |
| 0x41 | btsnoop_20260204_183225+ | Preceded by `d56d8c`, not ATT |
| 1x 0x46 | btsnoop_20260203_200749 | One of two 0x46 matches was false |

### Already-documented packets confirmed

| Type | Role | First seen | Count across captures |
|------|------|------------|----------------------|
| 0x46 (Schedule Config) | Notification | Feb 3 | Occasional |
| 0x47 (Schedule Query) | Notification | Feb 3 | Occasional |
| 0x50 (Holiday Status) | Notification | Feb 2 (earliest capture) | Every capture |

0x50 has been present since our earliest captures, so it's not new to the
firmware update.

## Extractor improvement needed

The `extract_packets.py` name map is missing 0x40, 0x46, 0x47, and 0x50.
It also has no false-positive filtering (ATT framing check). These could be
improved to reduce noise in future analysis.

## Open questions

- Is 0x40 the only way to write schedule config, or does 0x1a (SETTINGS) with
  mode byte 0x05 also play a role?
- What triggers the device to send 0x47 (Schedule Query)? → *Resolved: REQUEST param 0x26*
- Is there a HIGH mode byte for schedule slots? → *Resolved: 0x3C (60 decimal)*
- Did the firmware update change any packet behavior, or are the "new" 0x40
  packets just the first time we captured a schedule write?

---

# 2026-02-06: Holiday mode fully decoded and implemented (Issue #3)

## Verification capture

Ran a controlled capture session (`holiday_verify_byte43_20260206_100345`) with
four checkpoints: OFF → 3 days → 7 days → OFF.

**Byte 43 transitions observed in DEVICE_STATE packets:**
- `0 → 3` (holiday set to 3 days)
- `3 → 7` (changed to 7 days)
- `7 → 0` (holiday cleared)

All transitions match the values sent via REQUEST param 0x1a. Confirmed across
both Feb 5 and Feb 6 captures (values 0, 3, 5, 7 all observed).

## Key discovery: Device responds with DEVICE_STATE, not SETTINGS_ACK

When the device receives a holiday command (REQUEST param 0x1a), it responds
with a **DEVICE_STATE** packet (~130ms later), NOT a SETTINGS_ACK. This is
different from SETTINGS commands which do get SETTINGS_ACK.

The initial `set_holiday()` implementation waited for SETTINGS_ACK (following
the `set_boost()` pattern) and timed out in e2e tests. Fixed to wait for
DEVICE_STATE instead.

Note: `set_boost()` also gets DEVICE_STATE responses, not SETTINGS_ACK. It
works in the VMI app workflow because the app sends a full data request
afterward which triggers ACK. Standalone usage might also have this issue.

## Implementation

- `build_holiday_command(days)` — sends REQUEST 0x1a with days in byte 9
- `DeviceStatus.holiday_days` — parsed from DEVICE_STATE byte 43
- `VisionAirClient.set_holiday(days)` / `clear_holiday()` — client methods
- Removed `build_request_1a()` and `build_holiday_activate()` (dead code)
- E2e test passes: set 3 days → verify holiday_days=3 → clear → verify 0

## Open questions resolved

- Holiday mode: fully decoded, no separate activation packet needed
- 0x50 response: constant, not useful for state monitoring
- Byte 43: reliable source for holiday days remaining

---

# 2026-02-06: Schedule protocol fully decoded (Issue #2, Phases 1-3)

## Controlled capture sessions (Runs 1-6)

Ran 6 controlled VMI capture sessions via ADB to decode schedule protocol:

| Run | Action | Key discovery |
|-----|--------|---------------|
| 1 | Open Time Slot screen | Baseline 0x46/0x47 responses |
| 2 | Toggle time slots ON | REQUEST param 0x1D, value=1 |
| 3 | Toggle time slots OFF | REQUEST param 0x1D, value=0 |
| 4 | Change hour 0 LOW→MEDIUM | SCHEDULE_WRITE 0x40, mode byte 0x32 |
| 5 | Change hour 0 MEDIUM→HIGH | Mode byte 0x3C discovered |
| 6 | Change preheat 16°C→18°C | Temperature = raw Celsius value |

## Key discoveries

### HIGH mode byte: 0x3C (60 decimal)

Schedule slot mode bytes follow a 40/50/60 decimal pattern:
- LOW = 0x28 (40)
- MEDIUM = 0x32 (50)
- HIGH = 0x3C (60)

This is different from the settings airflow bytes (0x19/0x0A, 0x28/0x15, 0x07/0x30)
which use unrelated two-byte pairs.

### Schedule request triggers

| REQUEST param | Response | Purpose |
|---------------|----------|---------|
| 0x27 | 0x46 (SCHEDULE_CONFIG) | Read current schedule |
| 0x26 | 0x47 (SCHEDULE_QUERY) | Query schedule state |
| 0x1D (value 0/1) | UNKNOWN_05 | Toggle time slots ON/OFF |

### SCHEDULE_WRITE (0x40) behavior

- Device responds with SETTINGS_ACK (0x23) within ~200ms
- App sends full 24-hour schedule on every single-slot change
- Temperature encoding: raw Celsius value (16°C = 0x10, 18°C = 0x12)

## Implementation updates

- Added `build_schedule_config_request()` — REQUEST param 0x27
- Added `build_schedule_toggle(enable)` — REQUEST param 0x1D
- Updated `SCHEDULE_MODE_BYTES` with HIGH=0x3C
- Updated `get_schedule()` to use param 0x27 instead of Full Data Request
- Updated `set_schedule()` to wait for SETTINGS_ACK response
- Added tests against real captured packet data (Runs 4-6)

## Open questions resolved

- HIGH mode byte: 0x3C (was unknown)
- Schedule config trigger: REQUEST param 0x27 (not Full Data Request)
- Schedule toggle: REQUEST param 0x1D
- Device ack after write: SETTINGS_ACK (0x23)
