# 2026-02-07: Airflow mode indicator fix (#18)

## Capture session

Ran controlled capture `airflow_indicator_byte47_20260207` — toggled LOW → MEDIUM
→ HIGH on the phone while capturing btsnoop traffic.

## Findings

### Byte[47] indicator values were inverted

| REQUEST 0x18 value | Mode   | Byte[47] |
|-------------------|--------|----------|
| 0                 | LOW    | 0x68     |
| 1                 | MEDIUM | 0xC2     |
| 2                 | HIGH   | 0x26     |

### Airflow mode changes use REQUEST, not SETTINGS

The phone sends REQUEST param 0x18 with value 0/1/2 to change airflow mode. The
SETTINGS packet (0x1a) is NOT used for mode changes — it carries other config like
summer limit temperature and airflow volume bytes.

### get_fresh_status() was changing airflow mode

`build_sensor_select_request(2)` was actually sending REQUEST 0x18 value=2, which
set airflow to HIGH on every poll. This masked the indicator bug because byte[47]
was always 0x26 (HIGH), which was mapped to "low" due to the inverted values.

### Byte[34] = airflow mode index

Byte[34] in DEVICE_STATE reflects the mode index (0=LOW, 1=MEDIUM, 2=HIGH),
matching the value sent via REQUEST 0x18. Previously documented as "sensor selector".

## Code changes

- `AirflowIndicator`: LOW=0x68, MEDIUM=0xC2, HIGH=0x26
- `RequestParam.SENSOR_SELECT` → `AIRFLOW_MODE` (0x18)
- `build_sensor_select_request()` → `build_airflow_request()`
- `set_airflow()`: uses REQUEST 0x18 instead of SETTINGS packet
- `get_fresh_status()`: removed accidental mode-changing request
- `set_summer_limit()`: uses SETTINGS directly instead of delegating to set_airflow_mode()
- Documented REQUEST vs SETTINGS packet roles

## Open questions

- Byte[32] (TEMP_ACTIVE) shows different temps per mode — is Remote temp only
  available when mode index = 2?
- SETTINGS airflow bytes: phone sends different values than our code. What do they
  actually control if not airflow mode?

---

## Session 2: REQUEST 0x18 deep investigation

### What does REQUEST param 0x18 actually do?

We tried to determine whether 0x18 is "sensor select", "airflow mode", or both.

### Findings

#### 1. Byte-level diff: what changes in DEVICE_STATE after 0x18

Compared full 182-byte DEVICE_STATE packets before and after every 0x18 send
across all captures. Only 4-5 bytes consistently change:

| Byte | Changes | Description |
|------|---------|-------------|
| 32 | 8/8 | Temperature from selected sensor (13/16/19) |
| 34 | 8/8 | Selector index (matches the 0x18 value: 0/1/2) |
| 47 | 8/8 | Indicator (0x68/0xC2/0x26 — tracks selector) |
| 48 | 6/8 | Unknown (1 or 2) |
| 60 | 8/8 | Unknown, wide range — possibly humidity from selected sensor |

No other bytes change. Nothing that obviously represents "fan speed changed."

#### 2. Device autonomously enforces its schedule

Capture session `sensor_vs_fan_test_20260207_115842`:

- 13:00:01 — phone sends 0x18 value=0 (LOW). Device confirms LOW.
- 13:00:11 — phone polls (DEVICE_STATE_Q only, no 0x18). Device: LOW.
- 13:00:21 — phone polls. Device: LOW.
- 13:00:31 — phone polls. Device: **MEDIUM** — changed by itself!

No 0x18 or SETTINGS command was sent. The device changed mode autonomously.
The schedule has MEDIUM for hours 9-17, and it was noon.

**This means the LOW→MEDIUM transition we saw on screen was the schedule, not
sensor polling or 0x18 side effects.**

#### 3. The phone does NOT regularly cycle sensors during normal polling

During the entire 11-minute session, the phone's polling loop was:
`DEVICE_STATE_Q` + `FULL_DATA_Q` every 10 seconds. No 0x18 commands at all
except when we explicitly tapped the fan buttons.

The 0→1→2 "cycling" seen in the earlier capture session may have been triggered
by a specific app action (visiting measurements screen?) or may happen on a
longer interval. It is NOT part of the phone's regular 10-second polling loop.

#### 4. Sensor Management screen is for pairing, not selecting

The app's Sensor Management screen (Menu → Sensor management) only shows
configured sensors (e.g. "Remote control"). It does not let users select which
sensor to read from — there are no Probe 1/Probe 2 buttons.

### Conclusions (so far)

- 0x18 changes bytes 32/34/47/48/60 in DEVICE_STATE. It clearly controls
  sensor routing (which sensor's temp appears at byte 32).
- Whether 0x18 also changes the physical fan speed is **unresolved**. The byte
  diffs don't show obvious fan-speed-related changes beyond byte 47 (which we've
  been interpreting as an airflow indicator).
- The schedule is a confounding factor: the device can change mode without any
  phone command, and this may have been misattributed to 0x18 "doing both."
- The 0→1→2 cycling in earlier captures needs re-examination. It may not be
  sensor polling — or it may happen under specific conditions we haven't
  identified.

### What's needed next

1. **Disable the schedule** (`build_schedule_toggle(False)`) and re-test 0x18
   mode changes. Observe: does the device stay on the selected mode? Does the
   fan speed actually change? This isolates 0x18's effect from schedule
   interference.
2. **Investigate what triggers the 0→1→2 cycling.** Is it the measurements
   screen? A timer? Some other condition?
3. **Investigate byte 60** — it changes with every 0x18 transition and has a
   wide range. Likely the humidity from the selected sensor (relevant to #19).

---

## Session 3: Schedule toggle verified, first 0x18 experiment inconclusive

### Schedule toggle (`build_schedule_toggle`) verified

1. **Packet match:** Our code produces `a5b61006051d000000000e` (toggle OFF)
   and `a5b61006051d000000010f` (toggle ON), matching phone captures
   byte-for-byte from schedule_run2 and schedule_run3.
2. **UI confirmation:** Sent toggle OFF via BLE, then connected the VMI+ app.
   Configuration screen shows "Activating time slots: OFF" (red X) and the
   "Time slot configuration" button disappears. Re-enabled afterward.
3. **Documentation fix:** protocol.md had wrong packets for the schedule toggle
   (param 0x1d in wrong byte position, packet one byte too short). Fixed.

The toggle is at: VMI+ app → Menu → Configuration → "Activating time slots".

### First 0x18 experiment run (inconclusive)

Ran `test_0x18_fan_speed.py`. Step order was: set LOW → phone screenshot →
3-min wait. Result: phone showed HIGH, BLE confirmed HIGH after 3 min.

The phone app connected between setting LOW and the persistence check. This
means the phone connection is a confounding factor — it may have sent commands
that overrode the mode.

**Hypotheses (none verified):**
- H1: ~~Schedule toggle didn't work~~ — **eliminated** (verified above)
- H2: Phone app sends commands that change the mode when it connects
- H3: 0x18 LOW is transient and the device reverts on its own
- H4: Something else

Fixed experiment script to check BLE persistence before connecting the phone.
Second run not yet performed.

### A/B/A/B experiment results

Ran the A/B/A/B experiment from issue #22 comment. Schedule disabled, no phone during persistence checks, post-screenshot BLE readbacks.

| Phase | Target | BLE readbacks (7x 30s) | Phone screenshot | Post-screenshot BLE |
|-------|--------|----------------------|------------------|-------------------|
| A1 | LOW | 7/7 low | HIGH | high (PHONE SIDE EFFECT) |
| B1 | HIGH | 7/7 high | HIGH | high |
| A2 | LOW | 7/7 low | HIGH | high (PHONE SIDE EFFECT) |
| B2 | HIGH | 7/7 high | HIGH | high |

**Phone forces HIGH:** The phone sends 0x18=2 as part of its connection initialization, overriding any previously set mode. This is repeatable and consistent.

**DEVICE_STATE diffs (A1 LOW vs B1 HIGH):**
```
byte[ 32]: LOW=0x0d HIGH=0x13  (sensor temp)
byte[ 34]: LOW=0x00 HIGH=0x02  (selector)
byte[ 47]: LOW=0x68 HIGH=0x26  (indicator)
byte[ 48]: LOW=0x01 HIGH=0x02  (correlate)
byte[ 60]: LOW=0x3c HIGH=0x6d  (unknown)
```

No new bytes beyond the known 5.

**Open:** Physical fan speed change cannot be verified via the phone app. Need physical observation or temperature trends.

---

## Session 4: Physical listen test and remote control experiment

### Listen test: 0x18 does NOT change physical fan speed

With schedule disabled and no phone, cycled HIGH→LOW→HIGH→LOW (90s each, `test_0x18_listen.py`). Human listener next to the VMI reported no audible speed change in any phase. The VMI's physical remote display DID show the mode changes (confirmed LOW after 0x18=0).

**Conclusion:** 0x18 updates the mode state (visible in BLE bytes and on the remote display) but does NOT command the fan motor.

### Remote control changes both BLE state and physical speed

Tested the VMI's physical remote (RF, not BLE). BLE dumps taken after each change.

| Remote setting | Byte 44 (boost) | Byte 47 (indicator) | Physical fan | Airflow reported |
|---------------|-----------------|--------------------:|-------------|-----------------|
| LOW | 0x00 | 0x68 (LOW) | Low speed ✓ | 131 m³/h |
| MAX | **0x01** | 0x68 (LOW) | High speed ✓ | 131 m³/h |
| HIGH | 0x00 | 0x26 (HIGH) | High speed ✓ | 200 m³/h |
| LOW (back) | 0x00 | 0x68 (LOW) | Low speed ✓ | 131 m³/h |

- "MAX" on the remote activates boost mode (byte 44), not a fourth speed
- Fan speed ramps gradually (~15-20 seconds)
- The remote changes the same bytes (32/34/47/48/60) as 0x18, plus byte 44 for boost

### Implication

The remote communicates via RF. The VMI firmware handles the RF command by updating both the fan motor AND the BLE-visible state. Our BLE 0x18 command only updates the state bytes without triggering the motor. The actual BLE command for fan speed control is unknown — candidates include SETTINGS airflow bytes (#21) or an undiscovered REQUEST param.

### Not yet verified

- Remote → MEDIUM byte changes
- Whether SETTINGS time sync is required for 0x18 to affect the fan motor

---

## Session 5: Phone capture reveals SETTINGS = clock sync

### Capture session: `fan_speed_capture_20260207_171617`

Re-paired the phone app, tapped LOW → HIGH → LOW while capturing btsnoop traffic.

### Phone sends ONLY 0x18 for fan button taps

No SETTINGS packet accompanies the tap. The phone sends exactly the same 0x18
command we tested — the only difference is the phone's initialization sequence.

### SETTINGS "airflow bytes" are a timestamp

The phone sends SETTINGS every ~10s during polling. We assumed bytes 7-8 were
static airflow configuration bytes, but they change constantly. They're the
current time:

```
SETTINGS: a5b6 1a 0606 [summer_lim] [const] [day] [hour] [min] [sec] [checksum]
                          0x1a        0x02    ^^    ^^     ^^    ^^
```

Evidence from later packets (monotonically increasing):

| Day | Hour | Min | Sec | Time      |
|-----|------|-----|-----|-----------|
| 7   | 16   | 4   | 15  | 16:04:15  |
| 7   | 16   | 11  | 10  | 16:11:10  |
| 7   | 16   | 36  | 5   | 16:36:05  |
| 7   | 17   | 4   | 35  | 17:04:35  |
| 7   | 17   | 17  | 17  | 17:17:17  |

### Our SETTINGS byte 5 was misidentified

Our code sends `0x02` for byte 5 (we called it `summer_limit_enabled`). The
phone sends `0x06` or `0x07` — the current day. This was flagged earlier as
"phone sends 0x06, our code sends 0x02 — may need investigation."

### Hypothesis

The phone regularly syncs its clock to the VMI via SETTINGS. Our code never
does this. The device may require an up-to-date clock for 0x18 mode changes to
physically affect the fan motor. Needs testing.

---

## Session 6: Power monitoring dead-end

### Goal

Find an automated way to detect physical fan speed changes without a human
listener, so we can test whether time sync + 0x18 actually moves the fan.

### Approach: Shelly EM power monitoring

The house has a Shelly EM energy monitor (192.168.1.146) with two channels:
- Channel 1: Main power (whole house)
- Channel 2: Heat pump

The VMI is on the main circuit (channel 1), not monitored separately.

### Experiment

User changed the fan from LOW to MAX via the physical remote while we polled
the Shelly EM directly via HTTP API at 2-second intervals.

### Result: not usable

The main power channel oscillates 310-1600W in a ~20-second cycle from other
loads on the circuit. 20-second rolling averages showed no meaningful
difference between MAX and LOW periods (609W vs 664W — wrong direction,
within noise). Even with the preheat resistance heater drawing more power at
higher fan speed, the signal is buried under other household loads.

The heat pump channel (channel 2) was completely flat at ~129W in both modes,
confirming the VMI is not on that circuit.

### Why preheat matters

The preheat IS enabled (byte 53 = 0x01, confirmed in VMI+ app). At higher fan
speed, more cold air passes through the heat exchanger, so the electric
resistance heater works harder. This should add significant power draw beyond
just the fan motor. But even this larger delta is undetectable on the shared
main circuit.

Note: the `dump_raw_status.py` script has a bug — it checks byte 49 for
preheat instead of byte 53. Byte 49 showed 0 (OFF), which was misleading.

### Conclusion

Power monitoring via the Shelly EM cannot be used to detect VMI fan speed
changes. The main circuit has too much noise from other loads. A dedicated
power meter on the VMI's circuit would work but requires physical setup.

---

## Summary of measurement methods explored

| Method | Can detect fan speed? | Notes |
|--------|----------------------|-------|
| BLE DEVICE_STATE bytes | No | Same bytes change regardless of physical speed |
| VMI remote display | Yes (visual) | Shows mode, but requires human |
| Physical listening | Yes | Confirmed 0x18 ≠ speed change, remote = speed change |
| Phone app UI | Partially | Forces HIGH on connect, can't verify LOW |
| Shelly EM main power | No | Too much noise from other loads |
| Shelly EM heat pump ch. | No | VMI not on this circuit |
| PROBE_SENSORS byte 30 | Unknown | Jumped 16→31 between LOW/HIGH in one capture, unverified |

### Remaining approaches to try

1. **Physical listen test with init sequence** — next time user is near the VMI
2. **PROBE_SENSORS byte 30** — monitor this byte as automated proxy (needs verification first)
3. **Dedicated power meter** — most reliable but needs physical setup
